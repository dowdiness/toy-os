# チュートリアル: 16-bit Real Mode から 32-bit Protected Mode への移行

このチュートリアルでは、x86ブートローダーを16-bitリアルモードから32-bitプロテクトモードへ移行する方法を解説します。

## 目次

1. [背景: なぜプロテクトモードが必要か](#背景-なぜプロテクトモードが必要か)
2. [A20ラインの有効化](#a20ラインの有効化)
3. [GDT (Global Descriptor Table) の設定](#gdt-global-descriptor-table-の設定)
4. [プロテクトモードへの切り替え](#プロテクトモードへの切り替え)
5. [32-bitコードでの画面出力](#32-bitコードでの画面出力)
6. [完成コードの解説](#完成コードの解説)
7. [トラブルシューティング](#トラブルシューティング)

---

## 背景: なぜプロテクトモードが必要か

### リアルモードの制限

x86 CPUは起動時に **16-bit リアルモード** で動作します。このモードには以下の制限があります：

| 項目 | リアルモード | プロテクトモード |
|------|-------------|-----------------|
| アドレス空間 | 1MB | 4GB |
| レジスタサイズ | 16-bit | 32-bit |
| メモリ保護 | なし | あり |
| マルチタスク | 不可 | 可能 |

実用的なOSを作るには、プロテクトモードへの移行が必須です。

### 移行の3ステップ

```
1. A20ラインを有効化 (1MB以上のメモリにアクセス可能に)
2. GDTを設定 (セグメントの定義)
3. CR0レジスタのPEビットをセットしてジャンプ
```

---

## A20ラインの有効化

### A20とは？

IBM PC/ATの時代、8086との互換性のため、21番目のアドレスライン (A20) はデフォルトで無効でした。これにより、アドレスが1MBを超えると0に戻る「ラップアラウンド」が発生します。

```
アドレス 0x100000 (1MB) → 実際は 0x000000 にアクセス
```

プロテクトモードで1MB以上のメモリを使うには、A20を有効にする必要があります。

### 実装: Fast A20 方式

最もシンプルな方法は、システムコントロールポート (0x92) を使う「Fast A20」です：

```asm
# A20有効化 (Fast A20)
in $0x92, %al       # ポート0x92を読み取り
or $0x02, %al       # ビット1をセット (A20有効化)
and $0xFE, %al      # ビット0をクリア (システムリセット防止)
out %al, $0x92      # 書き戻し
```

> **注意**: 一部の古いハードウェアでは、キーボードコントローラ経由やBIOS INT 15h を使う必要があります。QEMUではFast A20で問題ありません。

---

## GDT (Global Descriptor Table) の設定

### GDTとは？

GDTは、メモリセグメントを定義するテーブルです。プロテクトモードでは、セグメントレジスタ (CS, DS, SS等) はGDT内のエントリを指すセレクタとなります。

### GDTエントリの構造 (8バイト)

```
 63       56 55    52 51    48 47       40 39       32
+----------+--------+--------+-----------+-----------+
| Base     | Flags  | Limit  | Access    | Base      |
| 24-31    | G D 0 A| 16-19  | Byte      | 16-23     |
+----------+--------+--------+-----------+-----------+
 31                         16 15                    0
+-----------------------------+----------------------+
| Base 0-15                   | Limit 0-15           |
+-----------------------------+----------------------+
```

### Access Byteの詳細

```
  7   6   5   4   3   2   1   0
+---+-------+---+---+---+---+---+
| P | DPL   | S | E | DC| RW| A |
+---+-------+---+---+---+---+---+

P   = Present (1 = セグメントが有効)
DPL = Descriptor Privilege Level (0 = カーネル, 3 = ユーザー)
S   = Descriptor type (1 = コード/データセグメント)
E   = Executable (1 = コード, 0 = データ)
DC  = Direction/Conforming
RW  = Readable/Writable
A   = Accessed
```

### 実装: 最小限のGDT

```asm
.align 8
gdt_start:
    .quad 0x0                      # エントリ0: ヌルディスクリプタ (必須)

gdt_code:                          # エントリ1 (セレクタ 0x08): コードセグメント
    .word 0xFFFF, 0x0000           # Limit 0-15, Base 0-15
    .byte 0x00                     # Base 16-23
    .byte 0b10011010               # Access: P=1, DPL=0, S=1, E=1, RW=1
    .byte 0b11001111               # Flags: G=1, D=1 + Limit 16-19
    .byte 0x00                     # Base 24-31

gdt_data:                          # エントリ2 (セレクタ 0x10): データセグメント
    .word 0xFFFF, 0x0000
    .byte 0x00
    .byte 0b10010010               # Access: P=1, DPL=0, S=1, E=0, RW=1
    .byte 0b11001111
    .byte 0x00

gdt_end:
```

### GDTディスクリプタ

`lgdt` 命令に渡す6バイトの構造体です：

```asm
gdt_descriptor:
    .word gdt_end - gdt_start - 1  # GDTのサイズ - 1
    .long gdt_start                # GDTの線形アドレス
```

> **重要**: `gdt_start` のアドレスは、リンカが配置した実際のアドレス (0x7c00 + オフセット) である必要があります。

---

## プロテクトモードへの切り替え

### 手順

1. 割り込みを無効化 (`cli`)
2. GDTをロード (`lgdt`)
3. CR0レジスタのPE (Protection Enable) ビットをセット
4. 32-bitコードセグメントへファージャンプ

### 実装

```asm
# GDTをロード
lgdt gdt_descriptor

# CR0のPEビットをセット
mov %cr0, %eax
or $0x1, %eax
mov %eax, %cr0

# 32-bitコードへファージャンプ
# セレクタ 0x08 = GDTの2番目のエントリ (コードセグメント)
ljmp $0x08, $pm_start
```

### なぜファージャンプが必要か？

`ljmp` (far jump) は以下を行います：
1. CSレジスタを新しいセレクタ (0x08) に更新
2. CPUのパイプラインをフラッシュ
3. 32-bitモードとしてコードを再解釈

---

## 32-bitコードでの画面出力

### BIOSが使えなくなる

プロテクトモードでは **BIOS割り込み (INT 10h等) は使用不可** です。画面出力には、VGAテキストバッファに直接書き込みます。

### VGAテキストモード

- アドレス: `0xB8000`
- サイズ: 80列 × 25行
- 各文字: 2バイト (文字 + 属性)

```
+--------+--------+
| 属性   | 文字   |
| (色)   | (ASCII)|
+--------+--------+
  Byte 1   Byte 0
```

### 属性バイト

```
  7     6   5   4     3   2   1   0
+-----+---+---+---+-----+---+---+---+
|Blink| Background  |  Foreground   |
+-----+-------------+---------------+
```

色コード:
- 0x00 = 黒
- 0x02 = 緑
- 0x07 = 白 (デフォルト)
- 0x0A = 明るい緑
- 0x0F = 明るい白

### 実装

```asm
.code32
pm_start:
    # データセグメントを設定
    mov $0x10, %eax        # セレクタ 0x10 = データセグメント
    mov %ax, %ds
    mov %ax, %es
    mov %ax, %ss
    mov $0x90000, %esp     # スタックポインタ

    # VGAメモリに文字列を書き込み
    mov $0xB8000, %edi     # VGAバッファのアドレス
    mov $msg_pm, %esi      # メッセージのアドレス
    mov $0x0A, %ah         # 属性: 明るい緑

.pm_print:
    lodsb                  # AL = *SI++
    test %al, %al          # ヌル文字チェック
    jz .pm_halt
    stosw                  # *DI++ = AX (文字 + 属性)
    jmp .pm_print

.pm_halt:
    hlt
    jmp .pm_halt

msg_pm: .asciz "32-bit Protected Mode OK!"
```

---

## 完成コードの解説

### ファイル構成

```
boot.s          # ブートセクタ (512バイト)
├── GDT定義     # 先頭付近に配置 (アドレス計算を簡単に)
├── 16-bit コード
│   ├── 初期化
│   ├── A20有効化
│   ├── GDTロード
│   └── プロテクトモード移行
└── 32-bit コード
    └── VGA出力
```

### 重要なポイント

1. **GDTは先頭付近に配置**: `gdt_descriptor` の `.long gdt_start` がリンカによって正しいアドレスに解決されます。

2. **アドレスの計算**: リンカは `-Ttext 0x7c00` でコードを0x7c00に配置します。すべてのラベルはこのベースアドレスからのオフセットとして計算されます。

3. **512バイト制限**: ブートセクタは512バイトちょうどでなければなりません。末尾に `.org 510` と `.word 0xAA55` でMBRシグネチャを配置します。

---

## トラブルシューティング

### 画面がチカチカする / 何も表示されない

**原因1: アドレス計算の誤り**
```asm
# NG: 手動でオフセット計算
.long gdt_start + 0x7c00

# OK: リンカに任せる
.long gdt_start
```

**原因2: 32-bitコードで16-bit命令を使用**
```asm
# NG
mov $0x10, %ax

# OK
mov $0x10, %eax
mov %ax, %ds
```

### Triple Fault (QEMUが即座に再起動)

- GDTが正しく設定されていない
- `ljmp` のセレクタが間違っている (0x08 = コードセグメント)
- 32-bitコードが `.code32` ディレクティブの後にない

### デバッグ方法

QEMUでデバッグ情報を表示：
```bash
qemu-system-i386 -drive format=raw,file=boot_512.img -d int,cpu_reset
```

---

## 次のステップ

プロテクトモードへの移行が完了したら、以下に進めます：

1. **ディスクからカーネルを読み込む**: 512バイトの制限を突破
2. **C言語でカーネルを書く**: アセンブリから `call` で呼び出し
3. **IDT (割り込みテーブル) を設定**: キーボード入力やタイマーの処理

---

## 参考資料

- [OSDev Wiki - Protected Mode](https://wiki.osdev.org/Protected_Mode)
- [OSDev Wiki - GDT](https://wiki.osdev.org/GDT)
- [OSDev Wiki - A20 Line](https://wiki.osdev.org/A20_Line)
- Intel® 64 and IA-32 Architectures Software Developer's Manual
